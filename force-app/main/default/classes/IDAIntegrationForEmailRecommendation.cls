/*
Description  : Perform callout to send EmailMessage body and Case data to IDA to identify Email recommendations

* version       Date                Owner                         Description
*******************************************************************************************************************
* V1.0          20/07/2023          Vivek@maersk                  SC-8488- Perform callout to send CaseDetails to IDA
* V2.0          23/01/2024          Vivek@maersk                  SC-9661  added method updateAIAgentUserFlagOnCase
* V3.0          06/03/2024          Meghna@maersk                 SC-9806  remove cases generated by excluded domains for recommendation
* V4.0          11/03/2024          Vivek@maersk                  SC-9866  added recordtype filter in method updateEmailRecommendationKPIs and added emailCaseStatus flag as part of gen1 api request
* V5.0          20/03/2024          Vivek@maersk                  SC-9916  created method getEmailResponseWithoutSignature for comparing users signature with Email Response and Removing Signature from emailbody for comparision
* V5.0          22/04/2024          Meghna@maersk                 SC-9543  created method sendCaseAndRecommendationDetailsToIDA for getting accuarcy of each email recommendation
* V6.0 			05/07/2024			Vazid						  created method getEmailAndCaseDetailsOnUpdate to re-trigger gen2 recommendations
*-------------------------------------------------------------------------------------------------------------------
*/
public class IDAIntegrationForEmailRecommendation {
    
    Public static List<Email_Domains_Excluded_From_Survey__mdt> emailDomainLst = Email_Domains_Excluded_From_Survey__mdt.getAll().values();
    
    public static void fetchEmailAndCaseDetails(EmailRecordSelector emailRecSelector){
       
        //SC-9806 
        List<String> excludedemaildomains = new List<String>();
        for(Email_Domains_Excluded_From_Survey__mdt domains:emailDomainLst){
            
            excludedemaildomains.add(domains.masterLabel);
        }
        Map<Id,Id> caseEmailMap = new Map<Id,Id>();
        Map<Id,Case> caseMap = new Map<Id,Case>();
        List<EmailMessage> emails=new List<EmailMessage>();
        emails = emailRecSelector.emailRecords;
        caseEmailMap = emailRecSelector.emailCaseIdMap;
        caseMap = emailRecSelector.mapRelatedCases;
        General_Key_Value_Configurations__mdt regionValues = General_Key_Value_Configurations__mdt.getInstance('IDARegionFieldCriteriaEmailRecommendatio');
        String emailRecommRecTypeId = Case_Recommendation__c.sObjectType.getDescribe().getRecordTypeInfosByName().get('Email Recommendation').getRecordTypeId();
        Map<Id, EmailMessage> emailCaseMap = new Map<Id, EmailMessage>();
        Set<Id> setAiResponseCreatorId = new Set<Id>();
        
        try{
            for(EmailMessage email : emails){
                if(!caseMap.isEmpty() && caseMap.containsKey(caseEmailMap.get(email.Id))){
                    Case caseToUpdate = caseMap.get(caseEmailMap.get(email.Id));
                    //condition to check for incoming email , external case, email channel, ocean product and regions bda code matches the metadata value if not global rollout
                    //recursion method to run the furture method only once per case.
                    String domain = email.FromAddress.split('@').get(1);
                    if(!excludedemaildomains.contains(domain) && email.Incoming && caseToUpdate.RecordTypeId == label.External_Case_RT_Id && caseToUpdate.Count_Case_Emails__c == 1 && caseToUpdate.Product__c == 'Ocean' && caseToUpdate.case_channel__c == 'E-mail' && !String.isEmpty(caseToUpdate.Country__c) && (regionValues.First_Field_Value__c == 'True'  ||( regionValues.First_Field_Value__c == 'False' && Label.IDACountryFieldCriteriaEmailRecommendation.containsIgnoreCase(CaseToUpdate.Country__r.name) )) && Generic_TriggerHandler.validateRunForMethod('IDAIntegrationForEmailRecommendation.sendCaseAndEmailDetailsToIDA()', 1)){                              
                        
                        CaseWrapper caseRecs = new CaseWrapper(); 
                        caseRecs.caseid = caseToUpdate.Id;
                        caseRecs.email_subject = email.subject;
                        caseRecs.recommendation_recordtypeid =emailRecommRecTypeId;
                        caseRecs.email_body = email.textBody;
                        caseRecs.country = caseToUpdate.country__r.name;
                        caseRecs.originCode=caseToUpdate.Origin;
                        caseRecs.emailCaseStatus = caseToUpdate.Status;
                        caseRecs.emailMessageID  = email.Id;
                        caseRecs.direction=caseToUpdate.Direction__c;
                        caseRecs.customerAccountCode = caseToUpdate.SCV_Code__c;
                        caseRecs.recipientEmail = email.ToAddress;
                        caseRecs.ccEmail = email.CcAddress;
                        caseRecs.fromEmail = email.FromAddress;
                        caseRecs.customerAccountName = caseToUpdate.Account.Name;
                        
                        String strBody = JSON.serialize(caseRecs);
                       
                        sendCaseAndEmailDetailsToIDA(strBody, false);
                        
                    }//else condition collect map for firing updateEmailRecommendationKPIs method
                    else if( !email.Incoming && caseToUpdate.RecordTypeId == label.External_Case_RT_Id &&/* for gen2 the recommendations will be visible for the entire case. caseToUpdate.Count_Case_Emails__c <= 2 && caseToUpdate.Total_Outbound_Emails_minus_Handshake__c <= 1 && */caseToUpdate.Product__c == 'Ocean' && caseToUpdate.case_channel__c == 'E-mail' && caseToUpdate.Email_Recommendation_Acceptance__c == 'Recommendations Available' && !String.isEmpty(caseToUpdate.Country__c) && ((regionValues.First_Field_Value__c == 'True' ) ||( regionValues.First_Field_Value__c == 'False' && Label.IDACountryFieldCriteriaEmailRecommendation.containsIgnoreCase(CaseToUpdate.Country__r.name)))){                              
                        emailCaseMap.put(caseToUpdate.Id, email);
                        setAiResponseCreatorId.add(email.createdById);
                    }
                }
            }
            //condition to fire method update monitoring KPIs method after the first outbound email is sent and Email_Recommendation_Acceptance__c is Recommendations Accepted
            if(!emailCaseMap.isEmpty()){
                UpdateEmailRecommendationKPIs(emailCaseMap, null ,setAiResponseCreatorId);
            }
        }catch(Exception ex) {
            ErrorLogger.writeErrors( 'SFDC', 'Case', 'IDAIntegrationForEmailRecommendation.fetchEmailAndCaseDetails', new list<Exception>{ex});  
        }
    }
    
    //Below method is to send the case details to IDA to retrigger gen2 recommendations
    public static void getEmailAndCaseDetailsOnUpdate(Map<Id,Case> mapOfUpdatedCases){
        
        List<String> excludedemaildomains = new List<String>();
        for(Email_Domains_Excluded_From_Survey__mdt domains:emailDomainLst){
            
            excludedemaildomains.add(domains.masterLabel);
        }
        General_Key_Value_Configurations__mdt regionValues = General_Key_Value_Configurations__mdt.getInstance('IDARegionFieldCriteriaEmailRecommendatio');
        String emailRecommRecTypeId = Case_Recommendation__c.sObjectType.getDescribe().getRecordTypeInfosByName().get('Email Recommendation').getRecordTypeId();
        String ResolutionRecommRecTypeId = Case_Recommendation__c.sObjectType.getDescribe().getRecordTypeInfosByName().get('Resolution Recommendation').getRecordTypeId();

        Map<Id, EmailMessage> mapOfCaseToEmailMsg = new Map<Id, EmailMessage>();
        List<Case> caseList = [Select id, (Select Id, ParentId, CreatedById, subject, CcAddress, ToAddress, FromAddress, textBody, Incoming from EmailMessages ORDER BY CreatedDate DESC LIMIT 1)
                               from case where Id In: mapOfUpdatedCases.keyset()];
        set<Id> accountIds = new set<Id>();
        for(Case caseRec: caseList){
            if(!caseRec.EmailMessages.isEmpty() && mapOfUpdatedCases.containskey(caseRec.Id)){
                mapOfCaseToEmailMsg.put(caseRec.Id, caseRec.EmailMessages[0]);
                accountIds.add(mapOfUpdatedCases.get(caseRec.Id).AccountId);// get latest account
            }
        }
        
        Map<ID, Account> mapOfAccounts = new Map<ID, Account>([SELECT Id, Name FROM Account Where Id In: accountIds]);

        if(!mapOfCaseToEmailMsg.isEmpty() && !mapOfCaseToEmailMsg.values().isEmpty()){
            try{
                for(Case caseRec : mapOfUpdatedCases.values()){
                    if(!mapOfCaseToEmailMsg.isEmpty() && mapOfCaseToEmailMsg.containsKey(caseRec.Id)){
                        EmailMessage email = mapOfCaseToEmailMsg.get(caseRec.Id);
                        //condition to check for incoming email , external case, email channel, ocean product and regions bda code matches the metadata value if not global rollout
                        //recursion method to run the furture method only once per case.
                        String domain = email.FromAddress.split('@').get(1);
                        if(!excludedemaildomains.contains(domain) && email.Incoming && caseRec.RecordTypeId == label.External_Case_RT_Id && caseRec.Count_Case_Emails__c == 1 && caseRec.Product__c == 'Ocean' && caseRec.case_channel__c == 'E-mail' && !String.isEmpty(caseRec.Country__c) && (regionValues.First_Field_Value__c == 'True'  ||( regionValues.First_Field_Value__c == 'False' ))){                              
                            
                            CaseWrapperForUpdate caseRecs = new CaseWrapperForUpdate(); 
                            caseRecs.caseid = caseRec.Id;
                            caseRecs.email_subject = email.subject;
                            caseRecs.recommendation_recordtypeid =emailRecommRecTypeId;
                            caseRecs.email_body = email.textBody;
                            caseRecs.country = caseRec.Case_Country__c;
                            caseRecs.originCode=caseRec.Origin;
                            caseRecs.emailCaseStatus = caseRec.Status;
                            caseRecs.emailMessageID  = email.Id;
                            caseRecs.direction=caseRec.Direction__c;
                            caseRecs.customerAccountCode = caseRec.SCV_Code__c;
                            caseRecs.recipientEmail = email.ToAddress;
                            caseRecs.ccEmail = email.CcAddress;
                            caseRecs.fromEmail = email.FromAddress;
                            if(mapOfAccounts.containskey(caseRec.AccountId)){
                                caseRecs.customerAccountName = mapOfAccounts.get(caseRec.AccountId).Name;
                            }
                            caseRecs.deliveryChannel = caseRec.Delivery_Channel__c;
                            caseRecs.reasonForCase = caseRec.Reason_For_Case__c;
                            caseRecs.productSubType = caseRec.Sub_Type__c;
                            
                            String strBody = JSON.serialize(caseRecs);
                            sendCaseAndEmailDetailsToIDA(strBody, true);
                            
                        }
                    }
                }
                
            }catch(Exception ex) {
                ErrorLogger.writeErrors( 'SFDC', 'Case', 'IDAIntegrationForEmailRecommendation.getEmailAndCaseDetailsOnUpdate', new list<Exception>{ex});  
            }
        }
    }
    
    public static void updateEmailRecommendationKPIs(Map<ID, EmailMessage> emailCaseMap, Map<Id, Case> mapCasesToUpdateKPIsForAI , Set<Id> setAiResponseCreatorId) {
        system.debug('updateEmailRecommendationKPI');
        List<Case> caseList = new List<case>();        
        Map<Id, User> useridMap = new Map<Id, User>();
        Map<String, String> userSignatureMap = new Map<String, String>();
        Map<Id,List<Case_Recommendation__c>> mapcaserecommendation = new Map<Id,List<Case_Recommendation__c>>();
        Set<ID> accepetedCaseid = new Set<Id>();
        //query creator name from user table based on the email creator id
        if(!setAiResponseCreatorId.isEmpty() ){
            For(User thisUser : [Select id, Name, Email, Signature, CreatedById from User where Id In: setAiResponseCreatorId]){
                useridMap.put(thisUser.id, thisUser);
                userSignatureMap.put(thisUser.email, thisUser.Signature);
            }
        }
        
        Set<Id> setCaseIds = new Set<Id>();
        if(emailCaseMap != null && !emailCaseMap.isEmpty()){
            setCaseIds.addAll(emailCaseMap.keySet());
        }
        if(mapCasesToUpdateKPIsForAI != null && !mapCasesToUpdateKPIsForAI.isEmpty()){
            setCaseIds.addAll(mapCasesToUpdateKPIsForAI.keySet());
        }
        For(Case_Recommendation__c thisRecom: [SELECT Id,Email_Recommendation_Accuracy_Percent__c, case__c,recordtypeid,case__r.Country__c, case__r.Agent_Used_Email_Recommendation__c, case__r.lastmodifiedbyId,Action_Status__c,case__r.Change_in_Email_Recommendation_Usage__c, Email_Recommendation_Accepted_Time__c, case__r.status, case__r.Case_Reopened__c, case__r.Total_Outbound_Emails_minus_Handshake__c, priority__c ,email_recommendation__C, recommendation_summary__c, Name FROM case_Recommendation__C where (recordType.name='Email Recommendation' or recordType.name='Resolution Recommendation') and case__c IN: setCaseIds  and case__r.Email_Recommendation_Acceptance__c = 'Recommendations Available' and case__r.ART_with_Email_Recommendations__c  = null]){
           if(thisRecom.Email_Recommendation_Accuracy_Percent__c==null){
            
                if(mapcaserecommendation.containskey(thisRecom.case__c)){
                    mapcaserecommendation.get(thisRecom.case__c).add(thisRecom);
                }
                else{
                    mapcaserecommendation.put(thisRecom.case__c, new List<Case_Recommendation__c>{thisRecom});
                    //system.debug('map value'+mapcaserecommendation);
                } 
                if(thisRecom.Action_Status__c == 'Accepted'){
                    accepetedCaseid.add(thisRecom.case__c);
                }
            }
            if(thisRecom.Action_Status__c == 'Accepted' && (thisRecom.recordtypeId == CaseRecommendationManager.emailRecommRecTypeId || thisRecom.recordtypeId == CaseRecommendationManager.resolutionRecommRecTypeId)){
                Boolean emailMessageFlag = emailCaseMap != null && !emailCaseMap.isEmpty() && emailCaseMap.containsKey(thisRecom.case__c) ? true : false;
                Boolean resolutionSummaryFlag = mapCasesToUpdateKPIsForAI!= null && !mapCasesToUpdateKPIsForAI.isEmpty() && mapCasesToUpdateKPIsForAI.containsKey(thisRecom.case__c) ? true : false;
                
                String createdByUserEmail = (emailMessageFlag == true && useridMap.containsKey(emailCaseMap.get(thisRecom.case__c).CreatedById)) ? useridMap.get(emailCaseMap.get(thisRecom.case__c).CreatedById).Email : (resolutionSummaryFlag == true && useridMap.containsKey(mapCasesToUpdateKPIsForAI.get(thisRecom.case__c).lastmodifiedbyId)) ? useridMap.get(mapCasesToUpdateKPIsForAI.get(thisRecom.case__c).lastmodifiedbyId).Email : '';
                
                Case updateCase  = new Case(Id = thisRecom.case__c);
                //write logic to compare the recommendation used in email body or compare the distance by calling getLevenshteinDistance method
                //if email.body contains recommList.email_Recommednation__c then 
                //update case field to either Copied -Used As is or Copied -Used partial
                //else update case field to Copied -Not used.
                //when recommendation is Copied and used in email body calculate the time taken in responding to user
                String responseBody ; 
                if(emailMessageFlag){
                    updateCase.ART_with_Email_Recommendations__c = GetSecondsElapsed(thisRecom.Email_Recommendation_Accepted_Time__c.time(), emailCaseMap.get(thisRecom.case__c).createddate.time());
                    
                    //Spliting the email response by the latest email response
                    responseBody = emailCaseMap.get(thisRecom.case__c).TextBody.split('--------------- Original Message ---------------')[0];
                }
                else if(resolutionSummaryFlag){
                    updateCase.ART_with_Email_Recommendations__c = GetSecondsElapsed(thisRecom.Email_Recommendation_Accepted_Time__c.time(), mapCasesToUpdateKPIsForAI.get(thisRecom.case__c).closedDate.time());
                    
                    //getting resolution summary as responseBody
                    responseBody = mapCasesToUpdateKPIsForAI.get(thisRecom.case__c).resolution_summary__c;
                }
                //conditions for picklist values Copied - Used as is and User Partial
                // String emailBody = emailCaseMap.get(thisRecom.case__c).TextBody.split('--------------- Original Message ---------------')[0];
                
                //if recommendation is used as partial in email body call getLevenshteinDistance method
                String emailRecommendationWithoutHTML  = thisRecom.email_recommendation__c.stripHtmlTags().trim();
                Map<String, String> responsBodyWithoutSignatureMap = getEmailResponseWithoutSignature( responseBody.stripHtmlTags(), !String.isBlank(userSignatureMap.get(createdByUserEmail)) ? userSignatureMap.get(createdByUserEmail).stripHtmlTags() : '');
                responseBody = responsBodyWithoutSignatureMap.keySet().tostring().removeStart('{').removeEnd('}');
                
                //Decimal differenceCharacters = getLevenshteinDistance(responseBody.trim(),emailRecommendationWithoutHTML);
                
                Decimal minimumLength = !responsBodyWithoutSignatureMap.isEmpty() && responsBodyWithoutSignatureMap.values()[0] == 'false' ? 60 : 20; //20 characters for BL and Container no edits
                List<String> emailRecomList = emailRecommendationWithoutHTML.split(' ');
                
                List<String> responseBodyList = responseBody.split(' ');
                
                Integer countOfCharMatching =0;
                Integer countOfCharExtra =0;
                
                //loop thru responseBody (emailMessage response Or resolutionsummary response) to check the works with email recommendation body
                for(String thisString : responseBodyList){
                    if(emailRecomList.contains(thisString) ){
                        countOfCharMatching=countOfCharMatching + thisString.length();
                    }
                    else{
                        countOfCharExtra = countOfCharExtra + thisString.length(); 
                    }
                    
                }
                
                if((countOfCharExtra-minimumLength) <= 0 ) //if edits after removing the minimumlength is less then equal to 0 . its a case of copied-used as is
                {
                    //if recommendation is used as is in email body
                    updateCase.Email_Recommendation_Acceptance__c = 'Copied - Used As Is';
                    updateCase.Change_in_Email_Recommendation_Usage__c = 0;
                    updateCase.Agent_Used_Email_Recommendation__c =  createdByUserEmail;        
                }else if((countOfCharExtra-minimumLength) >= 0 ){ // Copied - not used OR Copied - User Partial
                    
                    if( countOfCharMatching > 10){
                        
                        updateCase.Email_Recommendation_Acceptance__c = 'Copied - Used Partial';
                        updateCase.Change_in_Email_Recommendation_Usage__c = Math.round(math.abs((countOfCharExtra-minimumLength)/(responseBody.length()-minimumLength))*100);
                        updateCase.Agent_Used_Email_Recommendation__c =  createdByUserEmail;        
                        
                    }
                    else {
                        //condition to update the picklist value to Copied - not used
                        updateCase.Email_Recommendation_Acceptance__c = 'Copied - Not Used';  
                        updateCase.Agent_Used_Email_Recommendation__c =  createdByUserEmail; 
                        updateCase.Change_in_Email_Recommendation_Usage__c = Math.round(math.abs((countOfCharExtra-minimumLength)/(responseBody.length()-minimumLength))*100);
                        
                        
                    }
                    
                }
                caseList.add(updateCase);
            }
        }
        
        
        try{ 
            if(caseList!= null && !caseList.isEmpty()){
                //  TriggerExecutionController.skipCaseTrigger(true);
                update caseList;
                // TriggerExecutionController.skipCaseTrigger(false);
            }
        }
        catch(Exception ex) {
            System.debug(Logginglevel.ERROR, 'Exception! ' + ex.getMessage());
            ErrorLogger.writeErrors( 'SFDC', 'KPI updates Fail', 'IDAIntegrationForEmailRecommendation.UpdateEmailRecommendationKPIs', new list<Exception>{ex});
        }
        
        
        try{
            Map<String,ID> recommendationOrder= new Map<String , ID>();
            for(Id caseid:mapcaserecommendation.keyset()){
                if(!accepetedCaseid.contains(caseid) && emailCaseMap != null && !emailCaseMap.isEmpty() && emailCaseMap.containsKey(caseId)){
                    //if(!accepetedCaseid.contains(caseid)){
                    CaseWrapperRecom caserec = new CaseWrapperRecom();
                    caserec.caseID=caseid;
                    caserec.countryName=mapcaserecommendation.get(caseid)[0].case__r.Country__c;
                    caserec.emailBody=emailCaseMap.get(caseid).TextBody.split('--------------- Original Message ---------------')[0];
                    caserec.recommendation1=mapcaserecommendation.get(caseid)[0].Email_Recommendation__c;
                    recommendationOrder.put('1',mapcaserecommendation.get(caseid)[0].id);
                    if(mapcaserecommendation.get(caseid).size()>=2){
                        caserec.recommendation2=mapcaserecommendation.get(caseid)[1].Email_Recommendation__c;
                        recommendationOrder.put('2',mapcaserecommendation.get(caseid)[1].id);}
                    else{
                        caserec.recommendation2='';}
                    
                    if(mapcaserecommendation.get(caseid).size()>=3){
                        caserec.recommendation3=mapcaserecommendation.get(caseid)[2].Email_Recommendation__c;
                        recommendationOrder.put('3',mapcaserecommendation.get(caseid)[2].id);  }
                    else{
                        caserec.recommendation3='';}
                    
                    String strBody = JSON.serialize(caserec);
                    sendCaseAndRecommendationDetailsToIDA(strBody,recommendationOrder);   
                }
            }
            
        }
        catch(Exception ex)
        {
            system.debug('exception'+ex); 
            System.debug(Logginglevel.ERROR, 'Exception! ' + ex.getMessage());
            ErrorLogger.writeErrors( 'SFDC', 'KPI updates Fail(Accuracy)', 'IDAIntegrationForEmailRecommendation.UpdateEmailRecommendationKPIs', new list<Exception>{ex});
        }
        
        
    }
    @future(callout=true)
    public static void sendCaseAndEmailDetailsToIDA(String strBody, boolean isReTrigger) {
        system.debug('sendCaseAndEmailDetailsToIDA####');
        string strObjectName = 'IDAIntegrationForEmailRecommendation';
        string strModuleName = 'getEmailRecomDetails';
        
        AO_Services__mdt aoServiceDetail = WebserviceUtilities.getAOServicesMetadataValue(strObjectName,strModuleName);               
        Http h = new Http();
        HttpRequest req = new HttpRequest();
        req.setMethod('POST'); 
        req.setHeader('Accept','application/json');
        req.setHeader('Content-Type','application/json');
        req.setHeader('Consumer-Key',AOServiceDetail.Authorization_Key__c);
        req.setTimeout(Integer.valueof(aoServiceDetail.Timeout__c));
        string endPointURL = aoServiceDetail.End_point_URL__c;
        if(isReTrigger){
            endPointURL = endPointURL + '-retrigger';
        }
        system.debug('endPointURL####'+endPointURL);
        req.setEndpoint(endPointURL);
        req.setbody(strBody);
        String res;
        
        try{  
            res = AO_APILoginUtility.sendRequest(req,AOServiceDetail);
            system.debug('res####'+res);
            if(res.contains(Label.Token_Validation_Failed)){    
                Cache.Org.put('FRToken'+AOServiceDetail.Environment__c+AOServiceDetail.Authorization_Key__c,'',300);
                res = AO_APILoginUtility.sendRequest(req,AOServiceDetail);
            }
            
        }
        catch(Exception ex) {
            System.debug(Logginglevel.ERROR, 'Exception! ' + ex.getMessage());
            ErrorLogger.writeErrors( 'SFDC', strObjectName, 'IDAIntegrationForEmailRecommendation.fetchEmailAndCaseDetails', new list<Exception>{ex});
        }
    }
    
    //send case and recommendation details to IDA to get accuracy percentage
    @future(callout=true)
    public static void sendCaseAndRecommendationDetailsToIDA(String strBody,Map<String,ID> recommendationOrder) {
        List<Case> lstcasetoUpdate = new List<case>();
        List<Case_Recommendation__c> lstCaseRecom = new List<Case_Recommendation__c>();
        Set<ID> csRecommendationId= new Set<ID>();
        //List<RecommendationResponse> responseWrapper = new List<RecommendationResponse>();
        string strObjectName = 'IDAIntegrationRecomAccuracy';
        string strModuleName = 'getRecomAccurDetails';
        AO_Services__mdt aoServiceDetail = WebserviceUtilities.getAOServicesMetadataValue(strObjectName,strModuleName);               
        Http h = new Http();
        HttpRequest req = new HttpRequest();
        req.setMethod('POST'); 
        req.setHeader('Accept','application/json');
        req.setHeader('Content-Type','application/json');
        req.setHeader('Consumer-Key',AOServiceDetail.Authorization_Key__c);
        req.setTimeout(Integer.valueof(aoServiceDetail.Timeout__c));
        req.setEndpoint(aoServiceDetail.End_point_URL__c);
        req.setbody(strBody);
        String res;
        try{  
            res = AO_APILoginUtility.sendRequest(req,AOServiceDetail);
            if(res.contains(Label.Token_Validation_Failed)){    
                Cache.Org.put('FRToken'+AOServiceDetail.Environment__c+AOServiceDetail.Authorization_Key__c,'',300);
                res = AO_APILoginUtility.sendRequest(req,AOServiceDetail);
            }
            
            RecommendationResponse response = (RecommendationResponse)JSON.deserialize(res, RecommendationResponse.class);
            
            if(math.Max(math.Max(response.recommendation1Score,response.recommendation2Score),response.recommendation3Score)>0.95){
                Case updateCase  = new Case(Id = response.caseID,	AI_Relevance_percentage_Flag__c=true);
                lstcasetoUpdate.add(updateCase);
            }
            if(recommendationOrder.containsKey('1')){
                Case_Recommendation__c cr= new Case_Recommendation__c(Id = recommendationOrder.get('1'),Email_Recommendation_Accuracy_Percent__c=(response.recommendation1Score*100).setscale(2));
                lstCaseRecom.add(cr);                
            }
            if(recommendationOrder.containsKey('2')){
                Case_Recommendation__c cr= new Case_Recommendation__c(Id = recommendationOrder.get('2'),Email_Recommendation_Accuracy_Percent__c=(response.recommendation2Score*100).setscale(2));
                lstCaseRecom.add(cr);                
            } 
            if(recommendationOrder.containsKey('3')){
                Case_Recommendation__c cr= new Case_Recommendation__c(Id = recommendationOrder.get('3'),Email_Recommendation_Accuracy_Percent__c=(response.recommendation3Score*100).setscale(2));
                lstCaseRecom.add(cr);                
            }
            
            
            
            
            
            
            if(lstcasetoUpdate!= null && !lstcasetoUpdate.isEmpty()){
                TriggerExecutionController.skipCaseTrigger(true);
                update lstcasetoUpdate;
                TriggerExecutionController.skipCaseTrigger(false);
            }
            
            if(lstCaseRecom!= null && !lstCaseRecom.isEmpty()){
                update lstCaseRecom;
            }
        }
        
        catch(Exception ex) {
            System.debug(Logginglevel.ERROR, 'Exception! ' + ex.getMessage());
            ErrorLogger.writeErrors( 'SFDC', strObjectName, 'IDAIntegrationForEmailRecommendation.sendCaseAndRecommendationDetailsToIDA', new list<Exception>{ex});
        }
        
    }
    
    /** 
* @description | SC-9661 update Ai Agent Email Recommendation User              flag for cases where owener has access to ai permissionset
* @param lstCases accepts the list of Case Records
* @param mapOldCases accepts key value pair with Id and Case record
* @param mapCasesForAiAgentUpdate accepts cases with case id and record for Ocean, Email, External cases
*/
    public static void updateAIAgentUserFlagOnCase(list<Case> lstCases, map<Id, Case> mapOldCases, Map<Id, Case> mapCasesForAiAgentUpdate){
        try{
            
            List<String> excludedemaildomains = new List<String>();
            
            for(Email_Domains_Excluded_From_Survey__mdt domains:emailDomainLst){
                
                excludedemaildomains.add(domains.masterLabel);
            }
            set<Id> caseOwnerId= new Set<Id> ();
            map<Id, String> caseRecommMap  =  new map<Id, String>();            
            
            for(Case newCase : [Select id, OwnerId, SuppliedEmail, Contact_Email__c, AI_Agent_Email_Recommendation_User__c, AI_Agent_Resolution_Recommendation_User__c , (Select id, recordtypeId from Recommendations__r) From Case where Id IN: lstCases]){
                
                if(!mapCasesForAiAgentUpdate.isEmpty() && mapCasesForAiAgentUpdate.containsKey(newCase.id) ){ 
                    caseOwnerId.add(newCase.OwnerId);
                }
                if(newCase.Recommendations__r != null && newCase.Recommendations__r.size()>0){
                    for(Case_Recommendation__C thisCR: newCase.Recommendations__r){
                        if(thisCR.recordtypeId == CaseRecommendationManager.emailRecommRecTypeId){
                            caseRecommMap.put(newCase.id, 'Email Recommendation');
                            break;
                        }else if(thisCR.recordtypeId == CaseRecommendationManager.resolutionRecommRecTypeId){
                            caseRecommMap.put(newCase.id, 'Resolution Recommendation');
                            break;
                        }
                        
                    }
                }
            }
            
            Map<String, PermissionSetAssignment> usrMap = new Map<String, PermissionSetAssignment>();
            
            List<Id> genAIPermissionSetIds = new List<Id>();
            genAIPermissionSetIds.addAll(label.Gen_1_AI_Email_PermissionSets.split(','));
            
            if(!caseOwnerId.isEmpty()){               
                usrMap = StaticFactory.getCaseOwnerBasedonPermissionSet(genAIPermissionSetIds);
            }
            
            for(Case newCase : lstCases){
                
                String domain ='';
                
                if(newCase.SuppliedEmail != null){
                    
                    domain = newCase.SuppliedEmail.split('@').get(1);
                    
                }else if(newCase.Contact_Email__c != null){ 
                    
                    domain = newCase.Contact_Email__c.split('@').get(1);
                    
                }
                //gen 1 flag
                if(!excludedemaildomains.contains(domain) && !mapCasesForAiAgentUpdate.isEmpty() && mapCasesForAiAgentUpdate.containsKey(newCase.id) && newCase.AI_Agent_Email_Recommendation_User__c == false && !usrMap.isEmpty() && usrMap.containsKey(newCase.OwnerId+'--'+'Receive_Email_Recommendations') ){ 
                    newCase.AI_Agent_Email_Recommendation_User__c=  true;
                }
                //gen 2 flag
                if(!excludedemaildomains.contains(domain) && !mapCasesForAiAgentUpdate.isEmpty() && mapCasesForAiAgentUpdate.containsKey(newCase.id) && newCase.AI_Agent_Resolution_Recommendation_User__c == false  && !usrMap.isEmpty() && usrMap.containsKey(newCase.OwnerId+'--'+'Receive_Resolution_Recommendations') ){ 
                    newCase.AI_Agent_Resolution_Recommendation_User__c=  true;
                }
                
            }
            
        }
        catch(Exception ex){
            ErrorLogger.writeErrors( 'SFDC', 'Case', 'IDAIntegrationForEmailRecommendation.updateAIAgentUserFlagOnCase', new list<Exception>{ex}); 
        }
    }
    
    
    public class CaseWrapper{        
        public Id caseid;
        public string email_subject;
        public string country;
        public string recommendation_recordtypeid;
        public string email_body;
        public string originCode;
        public string direction;    
        public string emailCaseStatus;
        public string emailMessageID;
        public string customerAccountCode;
        public string recipientEmail;
        public string ccEmail;
        public String fromEmail;
        public String customerAccountName;
        
        public CaseWrapper(){
            caseid = this.caseid;
            email_subject = this.email_subject;
            country  = this.country;
            recommendation_recordtypeid = this.recommendation_recordtypeid;
            email_body = this.email_body;
            originCode = this.originCode;
            direction = this.direction;
            emailCaseStatus = this.emailCaseStatus;
            emailMessageID  = this.emailMessageID;
            customerAccountCode = this.customerAccountCode;
            recipientEmail = this.recipientEmail;
            ccEmail = this.ccEmail;
            fromEmail = this.fromEmail;
            customerAccountName = this.customerAccountName;
        }
    }
    
    Public class CaseWrapperRecom{        
        public Id caseID;
        public string countryName;
        public string emailBody;
        public string recommendation1;
        public string recommendation2;
        public string recommendation3;
        
        public CaseWrapperRecom(){
            caseID = this.caseid;
            countryName = this.countryName;
            emailbody=this.emailBody;
            recommendation1  = this.recommendation1;
            recommendation2 = this.recommendation2;
            recommendation3= this.recommendation3;
        }
    }
    
    Public class RecommendationResponse {
        public Decimal recommendation1Score { get; set; } 
        public Decimal recommendation2Score { get; set; } 
        public Decimal recommendation3Score { get; set; } 
        public String caseID { get; set; }
    }
    
    //SC-9916 
    public static Map<string,String> getEmailResponseWithoutSignature(String emailBody, String userSignature)
    {
        Map<String,String> emailBodyWithoutSignatureMap = new Map<String,String>();
        
        if(!String.isBlank(userSignature) ){
            if(emailBody.containsIgnoreCase(userSignature) ){
                Integer indexOfSignature =emailBody.indexOF(userSignature);
                String emailBodyTrimmed = emailBody.subString(0,indexOfSignature).trim();
                
                emailBodyWithoutSignatureMap.put(emailBodyTrimmed.trim(),'true');
                
            }else{
                
                emailBodyWithoutSignatureMap.put(emailBody,'false');
                
            }
        }
        else{
            emailBodyWithoutSignatureMap.put(emailBody,'false');
        }
        return emailBodyWithoutSignatureMap;
    }
    
    
    public static Integer getLevenshteinDistance(String emailBody, String emailRecommendation) {
        
        return emailRecommendation.getLevenshteinDistance(emailBody);
        
    }
    
    public static Integer getSecondsElapsed(Time emailRepyTime, Time recommAcceptedTime)
    {
        Integer elapsedSecondCount = getElapsedTime(emailRepyTime, recommAcceptedTime).second() + (GetElapsedTime(emailRepyTime, recommAcceptedTime).minute())*60 ;
        
        return elapsedSecondCount;
    }
    
    public static Time getElapsedTime(Time startTime, Time endTime)
    {
        if(startTime == null || endTime == null){
            return Time.newInstance(0, 0, 0, 0);
        }
        
        Integer elapsedHours = endTime.hour() - startTime.hour();
        Integer elapsedMinutes = endTime.minute() - startTime.minute();
        Integer elapsedSeconds = endTime.second() - startTime.second();
        Integer elapsedMiliseconds = endTime.millisecond() - startTime.millisecond();
        
        return Time.newInstance(elapsedHours, elapsedMinutes, elapsedSeconds, elapsedMiliseconds);
    }
    
    public class CaseWrapperForUpdate{        
        public Id caseid;
        public string email_subject;
        public string country;
        public string recommendation_recordtypeid;
        public string email_body;
        public string originCode;
        public string direction;    
        public string emailCaseStatus;
        public string emailMessageID;
        public string customerAccountCode;
        public string recipientEmail;
        public string ccEmail;
        public String fromEmail;
        public String customerAccountName;
        public String deliveryChannel;
        public string reasonForCase;
        public string productSubType;
        
        public CaseWrapperForUpdate(){
            caseid = this.caseid;
            email_subject = this.email_subject;
            country  = this.country;
            recommendation_recordtypeid = this.recommendation_recordtypeid;
            email_body = this.email_body;
            originCode = this.originCode;
            direction = this.direction;
            emailCaseStatus = this.emailCaseStatus;
            emailMessageID  = this.emailMessageID;
            customerAccountCode = this.customerAccountCode;
            recipientEmail = this.recipientEmail;
            ccEmail = this.ccEmail;
            fromEmail = this.fromEmail;
            customerAccountName = this.customerAccountName;
     		deliveryChannel = this.deliveryChannel;
            reasonForCase = this.reasonForCase; 
            productSubType =  this.productSubType;
        }
    }
}